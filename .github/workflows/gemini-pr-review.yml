name: Gemini PR Review

on:
  pull_request:
    types: [opened, synchronize, ready_for_review]  # New PRs, new commits, and draft->ready transitions
  workflow_dispatch:  # Allow manual re-runs without pushing commits

permissions:
  contents: read
  pull-requests: write

jobs:
  review:
    name: Gemini Code Review
    runs-on: ubuntu-latest
    # Only run on non-draft PRs, skip bot-created PRs, and require API key
    if: |
      github.event.pull_request.draft == false &&
      !contains(github.actor, '[bot]')

    steps:
      - name: Check for API key
        id: check-key
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "::notice::GEMINI_API_KEY not configured. Skipping AI review. Add this secret to enable Gemini PR reviews."
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - uses: actions/checkout@v4
        if: steps.check-key.outputs.skip != 'true'
        with:
          fetch-depth: 0  # Full history for better diff analysis
          token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Set up Python
        if: steps.check-key.outputs.skip != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Get PR diff and context
        if: steps.check-key.outputs.skip != 'true'
        id: diff
        env:
          # Pass PR body via env var to prevent shell injection
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          BASE="${{ github.event.pull_request.base.sha }}"
          HEAD="${{ github.event.pull_request.head.sha }}"

          echo "Comparing $BASE...$HEAD"
          # Use explicit git config to ensure consistent diff format
          git -c diff.noprefix=false diff "$BASE...$HEAD" --stat > /tmp/diff_stat.txt
          git -c diff.noprefix=false diff "$BASE...$HEAD" > /tmp/diff_full.txt

          # Get changed files list
          git diff --name-only "$BASE...$HEAD" > /tmp/changed_files.txt

          # Get commit messages for context (the "why")
          echo "Getting commit messages..."
          git log "$BASE...$HEAD" --pretty=format:"### %s%n%n%b%n---" > /tmp/commit_messages.txt

          # Generate commit context dynamically using the context generator
          # This analyzes the PR diff and generates structured context
          if [ -f ".claude/hooks/commit-context-generator.py" ]; then
            echo "Generating commit context from PR diff..."
            python3 .claude/hooks/commit-context-generator.py --base "$BASE" --head "$HEAD" --stdout > /tmp/commit_context.md 2>/dev/null || echo "Context generation failed" > /tmp/commit_context.md
          else
            echo "No commit context generator found" > /tmp/commit_context.md
          fi

          # Get PR body safely (via env var to prevent shell injection)
          printf '%s' "$PR_BODY" > /tmp/pr_body.txt

      - name: Install Google Gen AI SDK
        if: steps.check-key.outputs.skip != 'true'
        run: pip install google-genai>=1.51.0

      - name: Run Gemini Review
        if: steps.check-key.outputs.skip != 'true'
        id: review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          python << 'EOF'
          import os
          from google import genai

          # Create client with API key
          client = genai.Client(api_key=os.environ["GEMINI_API_KEY"])

          # Read diff files
          with open('/tmp/diff_stat.txt') as f:
              diff_stat = f.read()

          with open('/tmp/diff_full.txt') as f:
              diff_full = f.read()

          with open('/tmp/changed_files.txt') as f:
              changed_files = f.read()

          # Read context files for the "why"
          with open('/tmp/commit_messages.txt') as f:
              commit_messages = f.read()

          with open('/tmp/commit_context.md') as f:
              commit_context = f.read()

          with open('/tmp/pr_body.txt') as f:
              pr_body = f.read()

          # Truncate if too long
          max_diff_chars = 50000
          if len(diff_full) > max_diff_chars:
              diff_full = diff_full[:max_diff_chars] + "\n\n[... diff truncated due to size ...]"

          # Build context section
          context_section = ""
          if commit_messages.strip():
              context_section += f"""
          ## Commit Messages (Developer Intent)
          {commit_messages}
          """

          if pr_body.strip() and pr_body.strip() != "null":
              context_section += f"""
          ## PR Description
          {pr_body}
          """

          if commit_context.strip() and not any(x in commit_context for x in ["No commit context", "Context generation failed", "No changes"]):
              context_section += f"""
          ## Auto-Generated Change Context
          {commit_context}
          """

          prompt = f"""You are a senior code reviewer. Review this pull request diff and provide constructive feedback.

          ## Changed Files
          {changed_files}

          ## Diff Statistics
          {diff_stat}
          {context_section}
          ## Full Diff
          ```diff
          {diff_full}
          ```

          ## Review Guidelines

          Focus on:
          1. **Critical Issues** - Bugs, security vulnerabilities, data loss risks
          2. **Important Issues** - Performance problems, maintainability concerns
          3. **Suggestions** - Style improvements, best practices

          Consider the developer's intent from commit messages and PR description when reviewing.
          Be specific - reference file names and line numbers when possible.
          Be constructive - suggest solutions, not just problems.
          Be concise - focus on the most important issues.

          ## OUTPUT FORMAT (REQUIRED)

          You MUST respond with a valid TOML document. Do not include any text outside the TOML block.
          Use this exact structure:

          ```toml
          [review]
          summary = "Brief 1-2 sentence summary of the changes"
          decision = "APPROVE" # or "REQUEST_CHANGES" or "COMMENT"

          [[issues]]
          severity = "critical" # or "important" or "suggestion"
          file = "path/to/file.py"
          line = 42 # optional, omit if not applicable
          title = "Short issue title"
          description = "Detailed explanation of the issue"
          suggestion = "How to fix it" # optional

          [[issues]]
          severity = "suggestion"
          file = "another/file.js"
          title = "Another issue"
          description = "Description here"
          ```

          If there are no issues, use an empty issues array:
          ```toml
          [review]
          summary = "Clean PR with no issues found"
          decision = "APPROVE"
          ```
          """

          response = client.models.generate_content(
              model="gemini-3-pro-preview",
              contents=prompt,
          )

          review_text = response.text

          # Save raw TOML for debugging
          with open('/tmp/review_raw.toml', 'w') as f:
              f.write(review_text)

          # Parse TOML and format for GitHub
          import tomllib
          import re

          # Extract TOML from markdown code block if present
          toml_match = re.search(r'```toml\s*(.*?)\s*```', review_text, re.DOTALL)
          toml_content = toml_match.group(1) if toml_match else review_text

          try:
              review_data = tomllib.loads(toml_content)

              # Format as GitHub-friendly markdown
              summary = review_data.get('review', {}).get('summary', 'No summary provided')
              decision = review_data.get('review', {}).get('decision', 'COMMENT')
              issues = review_data.get('issues', [])

              # Decision emoji
              decision_emoji = {'APPROVE': '‚úÖ', 'REQUEST_CHANGES': 'üî¥', 'COMMENT': 'üí¨'}.get(decision, 'üí¨')

              output = f"**Summary:** {summary}\n\n"
              output += f"**Decision:** {decision_emoji} {decision}\n\n"

              if issues:
                  # Group by severity
                  critical = [i for i in issues if i.get('severity') == 'critical']
                  important = [i for i in issues if i.get('severity') == 'important']
                  suggestions = [i for i in issues if i.get('severity') == 'suggestion']

                  if critical:
                      output += "### üî¥ Critical Issues\n\n"
                      for issue in critical:
                          loc = f"`{issue.get('file', 'unknown')}"
                          if issue.get('line'):
                              loc += f":{issue['line']}"
                          loc += "`"
                          output += f"- **{issue.get('title', 'Issue')}** ({loc})\n"
                          output += f"  {issue.get('description', '')}\n"
                          if issue.get('suggestion'):
                              output += f"  > üí° {issue['suggestion']}\n"
                          output += "\n"

                  if important:
                      output += "### üü° Important Issues\n\n"
                      for issue in important:
                          loc = f"`{issue.get('file', 'unknown')}"
                          if issue.get('line'):
                              loc += f":{issue['line']}"
                          loc += "`"
                          output += f"- **{issue.get('title', 'Issue')}** ({loc})\n"
                          output += f"  {issue.get('description', '')}\n"
                          if issue.get('suggestion'):
                              output += f"  > üí° {issue['suggestion']}\n"
                          output += "\n"

                  if suggestions:
                      output += "### üü¢ Suggestions\n\n"
                      for issue in suggestions:
                          loc = f"`{issue.get('file', 'unknown')}"
                          if issue.get('line'):
                              loc += f":{issue['line']}"
                          loc += "`"
                          output += f"- **{issue.get('title', 'Issue')}** ({loc})\n"
                          output += f"  {issue.get('description', '')}\n"
                          if issue.get('suggestion'):
                              output += f"  > üí° {issue['suggestion']}\n"
                          output += "\n"
              else:
                  output += "No issues found. ‚ú®\n"

              # Add copyable TOML block (visible, not collapsed)
              output += "\n---\n\n"
              output += "### üìã Review Data (TOML)\n\n"
              output += "Copy this TOML for automation or tracking:\n\n"
              output += "```toml\n"
              output += toml_content.strip()
              output += "\n```\n"

              # Also keep collapsed raw response for debugging
              output += "\n<details>\n<summary>üîç Debug: Raw API Response</summary>\n\n```\n"
              output += review_text
              output += "\n```\n</details>"

              formatted_review = output

          except Exception as e:
              # Fallback: show raw response if TOML parsing fails
              formatted_review = f"‚ö†Ô∏è Failed to parse TOML response: {e}\n\n**Raw Response:**\n```\n{review_text}\n```"

          # Save formatted review for posting
          with open('/tmp/review.txt', 'w') as f:
              f.write(formatted_review)

          print(formatted_review)
          EOF

      - name: Post Review Comment
        if: success() && steps.check-key.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          REVIEW=$(cat /tmp/review.txt)
          PR_NUMBER="${{ github.event.pull_request.number }}"

          # Post as PR comment
          gh pr comment "$PR_NUMBER" --body "## ü§ñ Gemini Code Review

          $REVIEW

          ---
          *Automated review by Gemini. Please verify suggestions before applying.*"

      - name: Send Telegram notification
        if: success() && steps.check-key.outputs.skip != 'true'
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          # Skip if Telegram secrets not configured
          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
            echo "Telegram secrets not configured, skipping notification"
            exit 0
          fi

          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_TITLE="${{ github.event.pull_request.title }}"

          MESSAGE="ü§ñ *PR Review Complete*

          *PR #${PR_NUMBER}:* ${PR_TITLE}
          *Author:* ${{ github.actor }}

          [View PR](https://github.com/${{ github.repository }}/pull/${PR_NUMBER})"

          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "parse_mode=Markdown" \
            -d "text=${MESSAGE}" \
            -d "disable_web_page_preview=true"
